#  税收与补贴问题

## 题目背景

每样商品的价格越低，其销量就会相应增大。现已知某种商品的成本及其在若干价位上的销量（产品不会低于成本销售），并假设相邻价位间销量的变化是线性的且在价格高于给定的最高价位后，销量以某固定数值递减。（我们假设价格及销售量都是整数）

对于某些特殊商品，不可能完全由市场去调节其价格。这时候就需要政府以税收或补贴的方式来控制。（所谓税收或补贴就是对于每个产品收取或给予生产厂家固定金额的货币）

## 题目描述

你是某家咨询公司的项目经理，现在你已经知道政府对某种商品的预期价格，以及在各种价位上的销售情况。要求你确定政府对此商品是应收税还是补贴的最少金额（也为整数），才能使商家在这样一种政府预期的价格上，获取相对其他价位上的最大总利润。

总利润`=`单位商品利润 `\times` `×` 销量

单位商品利润`=`单位商品价格` -` 单位商品成本 （`-` 税金 `or +` 补贴）

## 输入输出格式

### 输入格式：

输入的第一行为政府对某种商品的预期价，第二行有两个整数，第一个整数为商品成本，第二个整数为以成本价销售时的销售量，以下若干行每行都有两个整数，第一个为某价位时的单价，第二个为此时的销量，以一行`-1` `−1`表示所有已知价位及对应的销量输入完毕，输入的最后一行为一个单独的整数表示在已知的最高单价外每升高一块钱将减少的销量。

### 输出格式：

输出有两种情况：若在政府预期价上能得到最大总利润，则输出一个单独的整数，数的正负表示是补贴还是收税，数的大小表示补贴或收税的金额最小值。若有多解，取绝对值最小的输出。

如在政府预期价上不能得到最大总利润，则输出“`NO SOLUTION`”。

### 输入样例#1：


    31
    28  130
    30  120
    31  110
    -1  -1
    15

### 输出样例#1： 


    4

### 说明:

所有数字均小于`100000`

## 题解：
    此题难点在于题意理解，其中两点比较难。
第一点，“假设邻价位间销量的变化是线性”，这意味着输入所给价格不是连续的，比如例子中28下面紧接着是30，那么就应该自己求出其间29所对应的销量；

另一个难点“你已经知道政府对某种商品的预期价格，以及各种价位上的销售情况。要求你确定政府对此商品是应收税还是补贴的最少金额（也为整数），才能使商家在这样一种政府预期的价格上，获取相对其他价位上的最大总利润。”，这句话理解起来不容易，用不等式描述更容易理解：
假设补贴`x`(`x`为正数即为补贴，`x`为负数则即为收税)，以样例为例，要求：

  `（31-28+x)*110 >= (28-28+x)*130`

  `（31-28+x)*110 >= (29-28+x)*125`

  `（31-28+x)*110 >= (30-28+x)*120`

  `（31-28+x)*110 >= (31-28+x)*110`

  `（31-28+x)*110 >= (32-28+x)*95`

               ···

 `（31-28+x)*110 >= (36-28+x)*25`

 `（31-28+x)*110 >= (37-28+x)*10`

以上一系列式子将决定`x`的最小值。下面我们结合程序来求解。
首先解决输入问题（第一个难点）。只要相邻价格不连续，就要以`1`元为单位补充价格，已知一段线段的两个端点坐标（相邻价格 `VS `销量）就可以求出其中任意一点坐标。已知直线一个点及其斜率，也能求出该线段上所有点坐标，输入的最高价格后所要补充的数据符合此种情况。

注意：政府定价有可能不在输入值中，而在补充值中，故要写几次，所附代码没有用子程序表达，显得啰嗦，用子程序过程将更简洁直观。

具体代码如下：

```c++
#include <iostream>
#include<cstdio>
#include<cmath> 
using namespace std;
/* run this program using the console pauser or add your own getch, system("pause") or input loop */
int a[100001][2];//根据题目要求定义数组
 
int main(int argc, char** argv) {
	int Gov_val;//输入政府定价
	scanf("%d",&Gov_val);
	int i,ifront,mark; 
	for ( i=1;i<=100000;i++){
		scanf("%d %d",&a[i][0],&a[i][1]);//循环输入价格及其对应销量。
		if (a[i][0]==(-1) && a[i][1]==(-1)) {
			i--;//输入“-1 -1”时数组停止输入，因该组不是价格销量故数组序号减1。
			break;
		}
		if(a[i][0]==Gov_val){
			mark=i;//如果输入数据是政府定价做个标记其下标以便用时容易找到。
		}
		if(i!=1 && a[i][0]-a[i-1][0]>1 ){//补充没有输入的数据，如果相邻两价格大于1
			int temp1=a[i][0];  //则两价格间还有其它价格及其销售量要补充
			int line=(a[i][1]-a[i-1][1])/(a[i][0]-a[i-1][0]);//求单位价格的销售变化量
			while((temp1-a[i-1][0])>=1){
				a[i][0]=a[i-1][0]+1;//在（i-1）后面的下标开始补充，价格依次加1
				a[i][1]=a[i-1][1]+line;//价格对应的销量，依次加上所求单位价格变化量
				if(a[i][0]==Gov_val){
					mark=i;//政府价格有可能没在输入数据中而在补充数据中
				}
				i++;//补充一个数后，下标加1，
			}
			i--;//因while循环最后i++,而外面的for循环又有i++，所以while循环外要减1。
		}
	}
    
	int reduce;//最后每升高1元减少的销售量。
	scanf("%d",&reduce);
    while(a[i][1]>0){//补充最后一个数字后的价格和销售量，点与斜率确定直线，可以求出直线上所有坐标。
		i++;
		a[i][0]=a[i-1][0]+1;
		a[i][1]=a[i-1][1]-reduce;
		if(a[i][0]==Gov_val){
			mark=i;
		}
	}
}
```

所有输入环节都结束了，接下来求解。

用代码中的量来表示不等式为:

`(a[mark][0]-a[1][0] + x) * a[mark][1] >= (a[1][0] - a[j][0] + x) * a[j][1]`

解此不等式，做一下变形把`x`单独拎出来，如下：

`(a[mark][1]-a[j][1])* x >= (a[1][0] - a[j][0]) * a[j][1]-(a[mark][0]-a[1][0]) * a[mark][1]`

依据题意`x`的系数在第`1`行至`mark-1`行时为负，在`mark+1`至最后一行为正。因此答案应该分段进行。

[1, mark-1]:
` x<=((a[mark][0]-a[1][0])*a[mark][1]+a[j][1]*(a[1][0]-a[j][0]))/(a[j][1]-a[mark][1])`
[mark+1, i]: `x>=(a[j][1]*(a[j][0]-a[1][0])-a[mark][1]*(a[mark][0]-a[1][0]))/(a[mark][1]-a[j][1])`

上面两个不等式可以得出`x`的区间，每行价格销售不等式可以得出一个解，所有解求交集，得出  `x_min=<x<=x_max`该区间绝对值最小的数即为所求数。因此有四种情况：

`1.`  `x_min > x_max` ，无解；

`2.` `x_max > x_min > 0` ，x的绝对值最小值是`x_min`；

`3.` `0 > x_max > x_min` ，x的绝对值最小值是`x_max`;

`4.` ` x_max > 0 >x_min` ，x的绝对值最小值是`0`;




```c++
int n=i;//价格种数
	float x,x_max=10000000,x_min=-10000000;
	for (int j=1;j<mark;j++){
		x=((a[mark][0]-a[1][0])*a[mark][1]*1.0+a[j][1]*(a[1][0]-a[j][0])*1.0)/(a[j][1]*1.0-a[mark][1]*1.0);//乘以1.0把整数强制转换成浮点数。
		if (x<=x_max){
			x_max=x;//每组价格销售数据都有一个解区间，求出最小的那个。
		}
	}
	for (int j=mark+1;j<=n;j++){
		x=(a[j][1]*(a[j][0]-a[1][0])*1.0-a[mark][1]*(a[mark][0]-a[1][0])*1.0)/(a[mark][1]*1.0-a[j][1]*1.0);
		if(x>=x_min){
			x_min=x;//每组价格销售数据都有一个解区间，求出最大的那个。
		}
	}
	int min,max;
	if(x_min>x_max) printf("NO SOLUTION");//第一种情况
	else if(x_min>0){//第二种情况
		if(fabs(x_min-(int)(x_min))>=0.000001)  min=(int)(x_min)+1;//x_min是个浮点数，而答案需要一个向上取得整数，所以在这里要区分x_min的值是不是整数。
		else  min=(int)(x_min);
		printf("%d",min);
	}
	else if(x_max<0){
		if(fabs((int)(x_max)-x_max)>=0.000001)  max=(int)(x_max)-1;//同上
		else  max=(int)(x_max);
		printf("%d",max);//第三种情况
	}
	else printf("0");//第四种情况
	return 0;
}
```