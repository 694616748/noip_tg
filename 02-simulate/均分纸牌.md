# 均分纸牌

## 题目描述

有NN堆纸牌，编号分别为 `1,2,…,N1,2,…,N。`每堆上有若干张，但纸牌总数必为`N`的倍数。可以在任一堆上取若干张纸牌，然后移动。

移牌规则为：在编号为`1`堆上取的纸牌，只能移到编号为`2`的堆上；在编号为`N`的堆上取的纸牌，只能移到编号为`N−1`的堆上；其他堆上取的纸牌，可以移到相邻左边或右边的堆上。

现在要求找出一种移动方法，用最少的移动次数使每堆上纸牌数都一样多。

例如`N=4`，`4`堆纸牌数分别为：

①`9`②`8`③`17`④`6`
移动`3`次可达到目的：

从 ③ 取`4`张牌放到 ④ `（9,8,13,10）->` 从 ③ 取`3`张牌放到 ②`（9,11,10,10）-> `从 ② 取`1`张牌放到①`（10,10,10,,10）`。

## 输入输出格式
### 输入格式：
两行

第一行为：`N`（`N` 堆纸牌，`1 ≤N≤100`）

第二行为：$A_1$, $A_2$ ... ,$A_n$（`N`堆纸牌，每堆纸牌初始数， 1 ≤$A_i$≤10000）


### 输出格式：
一行：即所有堆均达到相等时的最少移动次数。

输入输出样例
### 输入样例#1： 

4

9  8  17  6


### 输出样例#1： 
3

## 题解

此题乍一看容易思考混乱，因为最优答案都有多种摆法，比如所给样例，也可以先从`8`取一张到`9`，然后从`17` 取`3`张到`7`，取`4`张到`6`。这说明不能从具体移动方案找最少次数，应该跳出来思考总结规律。

以此题为例，低于10张的堆都需要其它堆支援，大于10张的堆都要支援其它堆。a[n]是第n堆牌数,move是移动总数，初始值为0.

1. `a[1]=9 < 10`,故至少需要其它堆移动一次牌过来，`move+1`,如果`a[1]=10`,则`move+0`,如果`a[1]>10`,则`move+1`;

2. `a[1]+a[2]< 20`, 把`a[1]`和`a[2]`看成是整体，则至少需要其它堆移动一次牌过来，`move+1`,如果`a[1]+a[2]= 20`,则`move+0`, 两堆纸牌只需要移动一次即可，如果`a[1]+a[2]> 20`,则`move+1`，需要把多余的移动到其它堆;

3. `a[1]+a[2]+a[3]> 30`, 把`a[1]`、`a[2]`和`a[3]`看成是整体，则这个整体至少需要向其它堆移动一次牌，`move+1`,若`a[1]+a[2]+a[3]= 30`,则`move+0`,整体平衡，无需移动，若`a[1]+a[2]+a[3] < 30`,则`move+1`，需要从其它堆移动到这个整体上;

4. `a[1]+a[2]+a[3]+a[4] = 40`，整体平衡，无需移动。虽然`a[4]=6`,但其需要移进来的`1`次在上一步已经算进第三次的移出了，不能重复加`1`。

至此移动规则很明显，从第`1`堆循环到第`n`堆，只要循环变量第`i`堆纸牌数量和不等于`i*10`,移动次数就加`1`，等于，移动次数加`0`。

```c++
#include <iostream>
#include <cstdio>
/* run this program using the console pauser or add your own getch, system("pause") or input loop */
int a[100];
int main(int argc, char** argv) {
	int n;
	scanf("%d",&n);
	int sum=0;
	for (int i=0;i<n;i++){
		scanf("%d",&a[i]);
		sum+=a[i];
	}
	int card=sum/n;//每堆平均数
	int temp_sum=0;
	int j=0;
	for (int i=0;i<n;i++){
		temp_sum+=a[i];
		if(temp_sum==card*(i+1)) {
			continue;
		}
		else{
			j++;
			
		}
	}
	printf("%d",j);
	return 0;
}
```