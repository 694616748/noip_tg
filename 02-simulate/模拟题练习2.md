# 模拟题练习2

## 乒乓球

### 题目背景

国际乒联现在主席沙拉拉自从上任以来就立志于推行一系列改革，以推动乒乓球运动在全球的普及。其中`11`分制改革引起了很大的争议，有一部分球员因为无法适应新规则只能选择退役。华华就是其中一位，他退役之后走上了乒乓球研究工作，意图弄明白`11`分制和`21`分制对选手的不同影响。在开展他的研究之前，他首先需要对他多年比赛的统计数据进行一些分析，所以需要你的帮忙。

### 题目描述

华华通过以下方式进行分析，首先将比赛每个球的胜负列成一张表，然后分别计算在`11`分制和`21`分制下，双方的比赛结果（截至记录末尾）。

比如现在有这么一份记录，（其中`W`表示华华获得一分，`L`表示华华对手获得一分）：

`WWWWWWWWWWWWWWWWWWWWWWLW`

在`11`分制下，此时比赛的结果是华华第一局`11`比`0`获胜，第二局`11`比`0`获胜，正在进行第三局，当前比分`1`比`1`。而在`21`分制下，此时比赛结果是华华第一局`21`比`0`获胜，正在进行第二局，比分`2`比`1`。如果一局比赛刚开始，则此时比分为`0`比`0`。直到分差大于或者等于`2`，才一局结束。

你的程序就是要对于一系列比赛信息的输入（`WL`形式），输出正确的结果。

#### 输入输出格式
#### 输入格式：
每个输入文件包含若干行字符串，字符串有大写的`W`、`L`和`E`组成。其中`E`表示比赛信息结束，程序应该忽略E之后的所有内容。

####  输出格式：
输出由两部分组成，每部分有若干行，每一行对应一局比赛的比分（按比赛信息输入顺序）。其中第一部分是`11`分制下的结果，第二部分是`21`分制下的结果，两部分之间由一个空行分隔。

#### 输入输出样例
#### 输入样例#1： 

    WWWWWWWWWWWWWWWWWWWW

    WWLWE
#### 输出样例#1： 

11:0

11:0

1:1



21:0

2:1

说明
每行至多`25`个字母，最多有`2500`行

### 题解

此题最简单的方法是定义四个计数变量，`countw1`（`11`分制赢球数）,`countl1`（`11`分制输球数）,`countw2`（`21`分制赢球数）,`countl2`（`21`分制输球数）。输入一个`W`，`countw1`和`countw2`各加`1`，输入一个`L`，`countl1`和`countl2`各加`1`,当输赢球数大于`2`，且有一个数大于等于`11`时，用数组分别存入这句比分，且计数器清零。输入`E`时，退出之前把比分存进数组。

### 代码

```C++
#include <iostream>
#include <cstdio>
#include <cmath>
using namespace std;
char a[62500];
int elevenw[62500],elevenl[62500],twelvew[62500],twelvel[62500];//分别为记录11分制赢球数、输球数、21分制赢球制和21分制输球数。
int main(){
    int i,n,j=0,k=0;
    int countw1=0,countl1=0,countw2=0,countl2=0;
    for (i=0;i<62500;i++){
            cin>>a[i];
            n++;
            if (a[i]=='E'){
                if (countw1!=0 || countl1!=0){//11分制，如果不是新一局开始，则要记录输赢计数器
                    elevenw[j]=countw1;
                 	elevenl[j]=countl1;
                }
                
                if (countw2!=0 || countl2!=0){//21分制，同上
                    twelvew[k]=countw2;
                 	twelvel[k]=countl2;
                }
                break;//停止接收E后面的W和L
            } 
            else if(a[i]=='W'){//输入一个W，赢计数器加1
                countw1++;
                countw2++;
            }
            else if(a[i]=='L'){//输入一个L，输计数器加1
                countl1++;
                countl2++;
            }
            if (countw1>=11 || countl1>=11){
                 if(abs(countw1-countl1)>=2){

                 	elevenw[j]=countw1;//一局结果存入数组
                 	elevenl[j]=countl1;
                    countw1=0;//清零
                    countl1=0;
                    j++;
                 }
            }
            if (countw2>=21 || countl2>=21){
                 if(abs(countw2-countl2)>=2){	//同上			 
                 	twelvew[k]=countw2;
                 	twelvel[k]=countl2;
                    countw2=0;
                    countl2=0;
                    k++;
                 }
            }
            
            
    }
    for (i=0;i<=j;i++){//输出结果
        printf("%d:%d\n",elevenw[i],elevenl[i]);
    }
    printf("\n");
    for (i=0;i<=k;i++){
        printf("%d:%d\n",twelvew[i],twelvel[i]);
    }
    return 0;
}

```

## 均分纸牌

### 题目描述

有NN堆纸牌，编号分别为 `1,2,…,N1,2,…,N。`每堆上有若干张，但纸牌总数必为`N`的倍数。可以在任一堆上取若干张纸牌，然后移动。

移牌规则为：在编号为`1`堆上取的纸牌，只能移到编号为`2`的堆上；在编号为`N`的堆上取的纸牌，只能移到编号为`N−1`的堆上；其他堆上取的纸牌，可以移到相邻左边或右边的堆上。

现在要求找出一种移动方法，用最少的移动次数使每堆上纸牌数都一样多。

例如`N=4`，`4`堆纸牌数分别为：

①`9`②`8`③`17`④`6`
移动`3`次可达到目的：

从 ③ 取`4`张牌放到 ④ `（9,8,13,10）->` 从 ③ 取`3`张牌放到 ②`（9,11,10,10）-> `从 ② 取`1`张牌放到①`（10,10,10,,10）`。

### 输入输出格式
#### 输入格式：
两行

第一行为：`N`（`N` 堆纸牌，`1 ≤N≤100`）

第二行为：$A_1$, $A_2$ ... ,$A_n$（`N`堆纸牌，每堆纸牌初始数， 1 ≤$A_i$≤10000）


#### 输出格式：

一行：即所有堆均达到相等时的最少移动次数。

输入输出样例

#### 输入样例#1： 

4

9  8  17  6


#### 输出样例#1： 
3

### 题解

此题乍一看容易思考混乱，因为最优答案都有多种摆法，比如所给样例，也可以先从`8`取一张到`9`，然后从`17` 取`3`张到`7`，取`4`张到`6`。这说明不能从具体移动方案找最少次数，应该跳出来思考总结规律。

以此题为例，低于10张的堆都需要其它堆支援，大于10张的堆都要支援其它堆。a[n]是第n堆牌数,move是移动总数，初始值为0.

1. `a[1]=9 < 10`,故至少需要其它堆移动一次牌过来，`move+1`,如果`a[1]=10`,则`move+0`,如果`a[1]>10`,则`move+1`;

2. `a[1]+a[2]< 20`, 把`a[1]`和`a[2]`看成是整体，则至少需要其它堆移动一次牌过来，`move+1`,如果`a[1]+a[2]= 20`,则`move+0`, 两堆纸牌只需要移动一次即可，如果`a[1]+a[2]> 20`,则`move+1`，需要把多余的移动到其它堆;

3. `a[1]+a[2]+a[3]> 30`, 把`a[1]`、`a[2]`和`a[3]`看成是整体，则这个整体至少需要向其它堆移动一次牌，`move+1`,若`a[1]+a[2]+a[3]= 30`,则`move+0`,整体平衡，无需移动，若`a[1]+a[2]+a[3] < 30`,则`move+1`，需要从其它堆移动到这个整体上;

4. `a[1]+a[2]+a[3]+a[4] = 40`，整体平衡，无需移动。虽然`a[4]=6`,但其需要移进来的`1`次在上一步已经算进第三次的移出了，不能重复加`1`。

至此移动规则很明显，从第`1`堆循环到第`n`堆，只要循环变量第`i`堆纸牌数量和不等于`i*10`,移动次数就加`1`，等于，移动次数加`0`。

### code

```c++
#include <iostream>
#include <cstdio>
/* run this program using the console pauser or add your own getch, system("pause") or input loop */
int a[100];
int main(int argc, char** argv) {
	int n;
	scanf("%d",&n);
	int sum=0;
	for (int i=0;i<n;i++){
		scanf("%d",&a[i]);
		sum+=a[i];
	}
	int card=sum/n;//每堆平均数
	int temp_sum=0;
	int j=0;
	for (int i=0;i<n;i++){
		temp_sum+=a[i];
		if(temp_sum==card*(i+1)) {
			continue;
		}
		else{
			j++;
			
		}
	}
	printf("%d",j);
	return 0;
}
```


##  税收与补贴问题

### 题目背景

每样商品的价格越低，其销量就会相应增大。现已知某种商品的成本及其在若干价位上的销量（产品不会低于成本销售），并假设相邻价位间销量的变化是线性的且在价格高于给定的最高价位后，销量以某固定数值递减。（我们假设价格及销售量都是整数）

对于某些特殊商品，不可能完全由市场去调节其价格。这时候就需要政府以税收或补贴的方式来控制。（所谓税收或补贴就是对于每个产品收取或给予生产厂家固定金额的货币）

### 题目描述

你是某家咨询公司的项目经理，现在你已经知道政府对某种商品的预期价格，以及在各种价位上的销售情况。要求你确定政府对此商品是应收税还是补贴的最少金额（也为整数），才能使商家在这样一种政府预期的价格上，获取相对其他价位上的最大总利润。

总利润`=`单位商品利润 `\times` `×` 销量

单位商品利润`=`单位商品价格` -` 单位商品成本 （`-` 税金 `or +` 补贴）

### 输入输出格式

#### 输入格式：

输入的第一行为政府对某种商品的预期价，第二行有两个整数，第一个整数为商品成本，第二个整数为以成本价销售时的销售量，以下若干行每行都有两个整数，第一个为某价位时的单价，第二个为此时的销量，以一行`-1` `−1`表示所有已知价位及对应的销量输入完毕，输入的最后一行为一个单独的整数表示在已知的最高单价外每升高一块钱将减少的销量。

#### 输出格式：

输出有两种情况：若在政府预期价上能得到最大总利润，则输出一个单独的整数，数的正负表示是补贴还是收税，数的大小表示补贴或收税的金额最小值。若有多解，取绝对值最小的输出。

如在政府预期价上不能得到最大总利润，则输出“`NO SOLUTION`”。

#### 输入样例#1：


    31
    28  130
    30  120
    31  110
    -1  -1
    15

#### 输出样例#1： 


    4

#### 说明:

所有数字均小于`100000`

### 题解：
    此题难点在于题意理解，其中两点比较难。
第一点，“假设邻价位间销量的变化是线性”，这意味着输入所给价格不是连续的，比如例子中28下面紧接着是30，那么就应该自己求出其间29所对应的销量；

另一个难点“你已经知道政府对某种商品的预期价格，以及各种价位上的销售情况。要求你确定政府对此商品是应收税还是补贴的最少金额（也为整数），才能使商家在这样一种政府预期的价格上，获取相对其他价位上的最大总利润。”，这句话理解起来不容易，用不等式描述更容易理解：
假设补贴`x`(`x`为正数即为补贴，`x`为负数则即为收税)，以样例为例，要求：

  `（31-28+x)*110 >= (28-28+x)*130`

  `（31-28+x)*110 >= (29-28+x)*125`

  `（31-28+x)*110 >= (30-28+x)*120`

  `（31-28+x)*110 >= (31-28+x)*110`

  `（31-28+x)*110 >= (32-28+x)*95`

               ···

 `（31-28+x)*110 >= (36-28+x)*25`

 `（31-28+x)*110 >= (37-28+x)*10`

以上一系列式子将决定`x`的最小值。下面我们结合程序来求解。
首先解决输入问题（第一个难点）。只要相邻价格不连续，就要以`1`元为单位补充价格，已知一段线段的两个端点坐标（相邻价格 `VS `销量）就可以求出其中任意一点坐标。已知直线一个点及其斜率，也能求出该线段上所有点坐标，输入的最高价格后所要补充的数据符合此种情况。

注意：政府定价有可能不在输入值中，而在补充值中，故要写几次，所附代码没有用子程序表达，显得啰嗦，用子程序过程将更简洁直观。

### 代码

```c++
#include <iostream>
#include<cstdio>
#include<cmath> 
using namespace std;
/* run this program using the console pauser or add your own getch, system("pause") or input loop */
int a[100001][2];//根据题目要求定义数组
 
int main(int argc, char** argv) {
	int Gov_val;//输入政府定价
	scanf("%d",&Gov_val);
	int i,ifront,mark; 
	for ( i=1;i<=100000;i++){
		scanf("%d %d",&a[i][0],&a[i][1]);//循环输入价格及其对应销量。
		if (a[i][0]==(-1) && a[i][1]==(-1)) {
			i--;//输入“-1 -1”时数组停止输入，因该组不是价格销量故数组序号减1。
			break;
		}
		if(a[i][0]==Gov_val){
			mark=i;//如果输入数据是政府定价做个标记其下标以便用时容易找到。
		}
		if(i!=1 && a[i][0]-a[i-1][0]>1 ){//补充没有输入的数据，如果相邻两价格大于1
			int temp1=a[i][0];  //则两价格间还有其它价格及其销售量要补充
			int line=(a[i][1]-a[i-1][1])/(a[i][0]-a[i-1][0]);//求单位价格的销售变化量
			while((temp1-a[i-1][0])>=1){
				a[i][0]=a[i-1][0]+1;//在（i-1）后面的下标开始补充，价格依次加1
				a[i][1]=a[i-1][1]+line;//价格对应的销量，依次加上所求单位价格变化量
				if(a[i][0]==Gov_val){
					mark=i;//政府价格有可能没在输入数据中而在补充数据中
				}
				i++;//补充一个数后，下标加1，
			}
			i--;//因while循环最后i++,而外面的for循环又有i++，所以while循环外要减1。
		}
	}
    
	int reduce;//最后每升高1元减少的销售量。
	scanf("%d",&reduce);
    while(a[i][1]>0){//补充最后一个数字后的价格和销售量，点与斜率确定直线，可以求出直线上所有坐标。
		i++;
		a[i][0]=a[i-1][0]+1;
		a[i][1]=a[i-1][1]-reduce;
		if(a[i][0]==Gov_val){
			mark=i;
		}
	}
}
```

所有输入环节都结束了，接下来求解。

用代码中的量来表示不等式为:

`(a[mark][0]-a[1][0] + x) * a[mark][1] >= (a[1][0] - a[j][0] + x) * a[j][1]`

解此不等式，做一下变形把`x`单独拎出来，如下：

`(a[mark][1]-a[j][1])* x >= (a[1][0] - a[j][0]) * a[j][1]-(a[mark][0]-a[1][0]) * a[mark][1]`

依据题意`x`的系数在第`1`行至`mark-1`行时为负，在`mark+1`至最后一行为正。因此答案应该分段进行。

[1, mark-1]:
` x<=((a[mark][0]-a[1][0])*a[mark][1]+a[j][1]*(a[1][0]-a[j][0]))/(a[j][1]-a[mark][1])`
[mark+1, i]: `x>=(a[j][1]*(a[j][0]-a[1][0])-a[mark][1]*(a[mark][0]-a[1][0]))/(a[mark][1]-a[j][1])`

上面两个不等式可以得出`x`的区间，每行价格销售不等式可以得出一个解，所有解求交集，得出  `x_min=<x<=x_max`该区间绝对值最小的数即为所求数。因此有四种情况：

`1.`  `x_min > x_max` ，无解；

`2.` `x_max > x_min > 0` ，x的绝对值最小值是`x_min`；

`3.` `0 > x_max > x_min` ，x的绝对值最小值是`x_max`;

`4.` ` x_max > 0 >x_min` ，x的绝对值最小值是`0`;




```c++
int n=i;//价格种数
	float x,x_max=10000000,x_min=-10000000;
	for (int j=1;j<mark;j++){
		x=((a[mark][0]-a[1][0])*a[mark][1]*1.0+a[j][1]*(a[1][0]-a[j][0])*1.0)/(a[j][1]*1.0-a[mark][1]*1.0);//乘以1.0把整数强制转换成浮点数。
		if (x<=x_max){
			x_max=x;//每组价格销售数据都有一个解区间，求出最小的那个。
		}
	}
	for (int j=mark+1;j<=n;j++){
		x=(a[j][1]*(a[j][0]-a[1][0])*1.0-a[mark][1]*(a[mark][0]-a[1][0])*1.0)/(a[mark][1]*1.0-a[j][1]*1.0);
		if(x>=x_min){
			x_min=x;//每组价格销售数据都有一个解区间，求出最大的那个。
		}
	}
	int min,max;
	if(x_min>x_max) printf("NO SOLUTION");//第一种情况
	else if(x_min>0){//第二种情况
		if(fabs(x_min-(int)(x_min))>=0.000001)  min=(int)(x_min)+1;//x_min是个浮点数，而答案需要一个向上取得整数，所以在这里要区分x_min的值是不是整数。
		else  min=(int)(x_min);
		printf("%d",min);
	}
	else if(x_max<0){
		if(fabs((int)(x_max)-x_max)>=0.000001)  max=(int)(x_max)-1;//同上
		else  max=(int)(x_max);
		printf("%d",max);//第三种情况
	}
	else printf("0");//第四种情况
	return 0;
}
```

## 铺地毯

### 题目描述

为了准备一个独特的颁奖典礼，组织者在会场的一片矩形区域（可看做是平面直角坐标系的第一象限）铺上一些矩形地毯。一共有 `n `张地毯，编号从 `1` 到 `n`。现在将这些地毯按照编号从小到大的顺序平行于坐标轴先后铺设，后铺的地毯覆盖在前面已经铺好的地毯之上。

地毯铺设完成后，组织者想知道覆盖地面某个点的最上面的那张地毯的编号。注意：在矩形地毯边界和四个顶点上的点也算被地毯覆盖。


### 输入格式：

输入共 `n+2` 行

第一行，一个整数 `n`, 表示总共有 `n` 张地毯

接下来的 `n` 行中，第 `i+1` 行表示编号i的地毯的信息，包含四个正整数 `a,b,g,k`, 每两个整数之间用一个空格隔开，分别表示铺设地毯的左下角的坐标 `(a,b)` 以及地毯在 `x` 轴和 `y` 轴方向的长度

第`n+2`行包含两个正整数 `x` 和 `y`，表示所求的地面的点的坐标`(x,y)`

### 输出格式：

输出共1行，一个整数，表示所求的地毯的编号；若此处没有被地毯覆盖则输出 `−1`。

### 输入样例#1： 

    3
    1 0 2 3
    0 2 3 3
    2 1 3 3
    2 2

### 输出样例#1： 

    3

### 输入样例#2： 

    3
    1 0 2 3
    0 2 3 3
    2 1 3 3
    4 5

### 输出样例#2：

    -1

### 样例解释

如下图，`1` 号地毯用实线表示，`2` 号地毯用虚线表示，`3`号用双实线表示，覆盖点`(2,2)`的最上面一张地毯是 3 号地毯。

![carpet](images/carpet.png)

### 数据范围

- 对于30% 的数据，有 `n≤2 `；
- 对于50% 的数据，`0 ≤a, b, g, k≤100`；
- 对于100%的数据，有` 0 ≤n ≤10,000`， `0≤ a, b, g, k ≤10,000` 。

noip2011提高组day1第1题

### 题解

拿到一道题首先要理解题意。此题比较容易理解，求出地面上某个点最上面的地毯编号。接着再看输入格式，此处给出解题可用条件。给出条件包括，地毯左下标坐标`(a,b)`及地毯在x轴和y轴长度信息`(g,k)`，还有所求点坐标。

理解题意及所给求解信息后，要从所求量着手挖掘隐藏条件来解题。例如此题，要求所给点的最上层地毯，必须要确定一个点是否在所给地毯所占区域内，怎么确定是这个题目的关键。一件地毯知道左下标又知道其在 `x` 轴和 `y` 轴上的长度，即可知道地毯`x`，`y`轴边界值（`x`轴范围为 `[a,a+g]`，`y`轴范围为`[b,b+k]`），只要所求点横纵坐标在边界范围内包括边界，即可认定此点被该地毯覆盖。

确定大概方法后，接着要思考数据，此题所给数据都在 `100 000` 以内，且求解没有累乘和累加，故用int整型就可以。

接着可以着手写程序，先些输入数据程序，需要设置一个二维矩阵表示 `n` 张地毯信息。

### 代码示例

```c++
#include <iostream>
#include<cstdio>
using namespace std;
int m[10001][5];
int main(int argc, char** argv) {
	int n;
	scanf("%d",&n);
	int i,j,flag=0;
	for (i=1;i<=n;i++){
		scanf("%d",&m[i][1]);//a
		scanf("%d",&m[i][2]);//b
		scanf("%d",&m[i][3]);//g
		scanf("%d",&m[i][4]);//k	
	}
	int x,y;
	scanf("%d",&x);
	scanf("%d",&y);
//搜索最顶上地毯，有两种方法，一种从第一张搜到最后一张，另一种从最后搜起，搜到的
//第一张即为最顶上一张。很明显第二种搜索次数小于或等于第一种方法，所以选择第二种。
	for (j=n;j>0;j--){
		if((x<=m[j][1]+m[j][3])&&(x>=m[j][1])&&(y>=m[j][2] && (y<=m[j][2]+m[j][4]))) {
				cout<<j;
				flag=1;
				break; //搜到最顶层地毯退出循环
		}
	}

	if (flag==0){
			cout<<-1;//没有符合条件的地毯，输出“-1”
	}

	return 0;
}
```