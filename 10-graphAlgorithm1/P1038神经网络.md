 # 神经网络   
 ## 题目描述  
人工神经网络（Artificial Neural NetworkArtificialNeuralNetwork）是一种新兴的具有自我学习能力的计算系统，在模式识别、函数逼近及贷款风险评估等诸多领域有广泛的应用。对神经网络的研究一直是当今的热门方向，兰兰同学在自学了一本神经网络的入门书籍后，提出了一个简化模型，他希望你能帮助他用程序检验这个神经网络模型的实用性。  
在兰兰的模型中，神经网络就是一张有向图，图中的节点称为神经元，而且两个神经元之间至多有一条边相连，下图是一个神经元的例子：  
![](images/p1038_1.png)   
神经元〔编号为1）
图中，X1-X3是信息输入渠道，Y1-Y2是信息输出渠道，C1表示神经元目前的状态，Ui是阈值，可视为神经元的一个内在参数。  
神经元按一定的顺序排列，构成整个神经网络。在兰兰的模型之中，神经网络中的神经元分为几层；称为输入层、输出层，和若干个中间层。每层神经元只向下一层的神经元输出信息，只从上一层神经元接受信息。下图是一个简单的三层神经网络的例子。  
![](images/p1038_2.png)  
兰兰规定，Ci服从公式：（其中nn是网络中所有神经元的数目）  
![](images/p1038_3.png)   
公式中的Wji（可能为负值）表示连接j号神经元和i号神经元的边的权值。当 Ci大于00时，该神经元处于兴奋状态，否则就处于平静状态。当神经元处于兴奋状态时，下一秒它会向其他神经元传送信号，信号的强度为Ci  
如此．在输入层神经元被激发之后，整个网络系统就在信息传输的推动下进行运作。现在，给定一个神经网络，及当前输入层神经元的状态（Ci），要求你的程序运算出最后网络输出层的状态。  
## 输入格式  
输入文件第一行是两个整数n(1≤n≤100)和p。接下来n行，每行2个整数，第i+1行是神经元i最初状态和其阈值（Ui），非输入层的神经元开始时状态必然为0。再下面P行，每行由2个整数i,j及1个整数Wij ，表示连接神经元i,j的边权值为Wij。  
 ## 输出格式  
输出文件包含若干行，每行有2个整数，分别对应一个神经元的编号，及其最后的状态，2个整数间以空格分隔。仅输出最后状态大于0的输出层神经元状态，并且按照编号由小到大顺序输出。
若输出层的神经元最后状态均为 0，则输出 “NULL”。
 ## 输入样例  
 ```c++	 
5 6  
1 0  
1 0  
0 1  
0 1  
0 1  
1 3 1  
1 4 1  
1 5 1  
2 3 1  
2 4 1  
2 5 1  
 ```    
 ## 输出样例  
 ```c++		
3 1  
4 1  
5 1  
 ```   
 ## 测试网站  	
  [P1038](https://www.luogu.org/problemnew/show/P1038)  	 
 ## 题目分析  	
题目要求输出层的状态并输出大于0的，而根据求状态的公式可以知道求当前神经元必须先求出上一层神经元的状态，
所以可以想到用bfs或拓扑排序模拟求状态的过程。这个题有一个坑：当神经元处于兴奋状态时，下一秒它会向其他神经元传送信号。就是说在求当前神经元状态时要判断它的前驱神经元是否大于0。  
这里用拓扑排序实现的，具体做法就是找到入度为0的点，放入队列，并计算其状态，算完后将与其连接的点的入度减一，直到队列为空。  
 ## 代码示例  
 ```c++	
#include<bits/stdc++.h>
using namespace std;
int n, p;
int c[101],u[101], num[101][101], w[101][101];
int in_degree[101], out_degree[101];
queue<int>q;
void tp_sort(){//拓扑排序
    while (!q.empty()){
        int now = q.front();//取出队列首的节点
        q.pop();
        for (int i=1; i<=n; i++){
            if(num[now][i] && c[now]>0){//如果该节点状态大于0则向下传递
                c[i] += c[now]*w[now][i];
            }
            --in_degree[i];//将与其连接的节点的入度减一
            if (in_degree[i]==0)//如果其入度为0，将其放入队列
                q.push(i);
        }
    }
}
int main(){
    cin>>n>>p;
    for (int i=1;i<=n;i++)
        cin>>c[i]>>u[i];
    for (int i=1;i<=p;i++){
        int u, v, c;
        cin>>u>>v>>c;
        num[u][v] = 1;//建邻接矩阵
        w[u][v] = c;//保存边权
        in_degree[v] ++;//入度
        out_degree[u] ++;//出度
    }
    for (int i=1;i<=n;i++)
        if (in_degree[i]==0)//将输入层放入队列
            q.push(i);
        else
            c[i]-=u[i];//可以先减去阈值
    tp_sort();
    bool fg=0;
    for(int i=1; i<=n; i++)
        if (c[i] > 0 && out_degree[i] == 0){//输出出度为0的点即输出层的点
            fg=1;
            cout << i << " " << c[i] << endl;;
        }
    if (!fg) printf("NULL");//如果没有神经元的状态大于0则输出NULL
    return 0;
}

```