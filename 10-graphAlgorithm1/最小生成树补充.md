# 最小生成树补充

## 做题链接：[GO](https://vjudge.net/contest/284355)

### Password：aomeng

## 题目一：Minimal Ratio Tree

[HDOJ 2489](http://acm.hdu.edu.cn/showproblem.php?pid=2489)

### 题意

给出一系列点和边，每个边和点都有一个权值，给定一个值`m`，选择一系列边，使这些边把任意`m`个点连接起来，边的权值和与点的权值和最小。

### 思路

假设我们已经选定`m`个点，那么点的权值就已经固定，那么我们需要做的便是使边的权值最小，易知就是求最小生成树。

至于如何选定`m`个点，我们可以观察到点的个数最大不会超过`15`，所以可以用`DFS`爆搜，但如果`DFS`每一层都遍历`n`个点，还是会超时的

所以我们的优化方法是按照顺序搜，每一层只判断当前点选与不选，那么每一层就变成只需要遍历两个状态。

### 代码

```c++
#include <bits/stdc++.h>
using namespace std;
#define mst(a,b) memset((a),(b),sizeof(a))
typedef long long ll;
const int maxn= 20;
const int mod = 475;
const ll INF = 0x3f3f3f3f;
const double eps = 1e-6;
#define rush() int T;scanf("%d",&T);while(T--)

int pre[maxn],d[maxn],vis[maxn];
int mp[maxn][maxn],output[maxn];
int n,m,cnt;
double Min;

struct node
{
    int x,y,w;
}a[maxn*maxn];

bool cmp(const node &a,const node &b)
{
    return a.w<b.w;
}
void init()
{
    for(int i=0;i<=n;i++)
        pre[i]=i;
}

int find(int x)
{
    int t,r=x;
    while(x!=pre[x])
    {
        x=pre[x];
    }
    while(r!=x)
    {
        t=pre[r];
        pre[r]=x;
        r=t;
    }
    return x;
}

void join(int a,int b)
{
    int A,B;
    A=find(a);
    B=find(b);
    if(A!=B)
        pre[B]=A;
}

void solve(int sum2)
{
    int sum1=0;
    int tot=0;
    cnt=0;
    init();
    for(int i=1;i<=n;i++)
    {
        if(vis[i]==1)
        {
            for(int j=i+1;j<=n;j++)
            {
                if(vis[j]==1)
                {
                    a[cnt].x=i;
                    a[cnt].y=j;
                    a[cnt++].w=mp[i][j];
                }
            }
        }
    }
    sort(a,a+cnt,cmp);
    for(int i=0;i<cnt;i++)
    {
        if(find(a[i].x)!=find(a[i].y))
        {
            join(a[i].x,a[i].y);
            sum1+=a[i].w;
            tot++;
        }
        if(tot==m-1)
            break;
    }
    double ans=sum1*1.0/sum2;
    tot=0;
    if(ans<Min||Min==-1)
    {
        Min=ans;
        for(int i=1;i<=n;i++)
        {
            if(vis[i]==1)
            {
                output[tot++]=i;
            }
        }
    }
}

void dfs(int num,int now,int sum2)
{
    if(now>n+1)
        return;
    if(num==m)
    {
        solve(sum2);
        return;
    }
    vis[now]=1;
    dfs(num+1,now+1,sum2+d[now]);
    vis[now]=0;
    dfs(num,now+1,sum2);
}
int main()
{
    while(~scanf("%d%d",&n,&m)&&(n||m))
    {
        for(int i=1;i<=n;i++)
        {
            scanf("%d",&d[i]);
        }
        for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
        {
            scanf("%d",&mp[i][j]);
        }
        mst(vis,0);
        Min=-1;
        dfs(0,1,0);
        for(int i=0;i<m-1;i++)
        {
            printf("%d ",output[i]);
        }
        printf("%d\n",output[m-1]);
    }
    return 0;
}
```

## 题目二：Envy

[Codeforces 892E](http://codeforces.com/problemset/problem/892/E)

### 题意

给你一系列边和其权值，保证利用这些边能够成最小生成树。再给出一系列询问，每个询问中有一些边，问这些边能否在一颗最小生成树中同时出现。

### 思路

首先我们明确一点，即对于一条权值为`w`的边来说，如果在所有权值小于`w`的边全部加入图后这条边的两个端点还没有联通的话，那么这条边能出现在最小生成树中。

而且对于每一组询问，权值相同的边会相互影响，而权值不相同的边的判断是相互独立的。

综上，我们得到一种做法：

先对给出边按权值排序记为`A`，再对询问中的边按权值(按询问)排序，记为`B`。

然后从小到大枚举`B`中的边权`w`，先把小于`w`的所有边加入到图`G1`中，然后把询问中边权为`w`的边一条条判断是否联通，若联通做标记，不连通的话在图`G2`中加入这条边。

值得注意的是，上一个操作第二步若边权等于`w`的边在多个询问中时，我们每次换到一个询问，应把`G2`还原为图`G1`，因为不同询问相同边权是不相互影响的。

具体细节见代码。

### 代码

```c++
#include <cstdio>
#include <cmath>
#include <map>
#include <cstring>
#include <algorithm>
using namespace std;
#define mst(a,b) memset((a),(b),sizeof(a))
#define rush() int T;scanf("%d",&T);while(T--)

typedef long long ll;
const int maxn = 1000005;
const ll mod = 1e9+7;
const ll INF = 0x3f3f3f3f;
const double eps = 1e-9;

int n,m,k;
int pre[maxn];
int pa[maxn];
int mark[maxn];
int ans[maxn];

struct node                 //储存边的信息
{
    int u,v,w;
    bool operator<(const node &a) const
    {
        return w<a.w;
    }
}a[maxn];

struct query                //储存查询中边的信息
{
    int id,u,v,w;
    bool operator<(const query &a) const
    {
        if(w==a.w) return id<a.id;
        return w<a.w;
    }
}q[maxn];

int find(int x)             //原图并查集
{
    return x==pre[x]?x:pre[x]=find(pre[x]);
}

int find2(int x,int tag)    
{
    if(mark[x]!=tag) pa[x]=pre[x],mark[x]=tag;  //不等于tag说明已经不在前一个询问里了，那么x点的前驱还原为在G1图中的前驱
    return x==pa[x]?x:pa[x]=find2(pa[x],tag);
}

int main()
{
    int x,y,w;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d%d",&x,&y,&w);
        a[i]=(node){x,y,w};
    }
    scanf("%d",&k);
    int tot=0;
    for(int i=1;i<=k;i++)
    {
        scanf("%d",&x);
        for(int j=1;j<=x;j++)
        {
            scanf("%d",&y);
            q[++tot]=(query){i,a[y].u,a[y].v,a[y].w};
        }
    }
    sort(a+1,a+1+m);
    sort(q+1,q+1+tot);
    for(int i=1;i<=n;i++) pre[i]=i,pa[i]=i;
    int pos1=1,pos2=1;
    int tag=0;
    for(int i=1;i<=tot;i=pos2)
    {
        while(a[pos1].w<q[i].w&&pos1<=m)       //把权值小于w的边加入到图G1中
        {
            int A=find(a[pos1].u);
            int B=find(a[pos1].v);
            if(A!=B) pre[B]=A;
            pos1++;
        }
        while(q[pos2].w==q[i].w&&pos2<=tot)                 //枚举询问中权值等于w的边
        {
            if(pos2==i||q[pos2].id!=q[pos2-1].id) tag++;    //换了一个询问，需要还原
            int A=find2(q[pos2].u,tag);
            int B=find2(q[pos2].v,tag);
            if(A==B) ans[q[pos2].id]=1;
            else pa[B]=A;
            pos2++;
        }
    }
    for(int i=1;i<=k;i++)
    {
        if(ans[i]) puts("NO");
        else puts("YES");
    }
}
```
