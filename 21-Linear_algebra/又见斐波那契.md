# 又见斐波那契


## 题目描述

这是一个加强版的斐波那契数列。 

给定递推式

![image](images/20180427154236975.png)

求`F(n)`的值，由于这个值可能太大，请对`1e9+7`取模。

## 输入格式

第一行一个整数`T`,表示数据组数

接下来`T`行,每行一个整数`n`,表示珠子总个数


## 输出格式

对于每组数据输出方案数,答案对`1e9+7`取膜。

## 输入样例

    2
    2
    3

## 输出样例

    3
    4
 
    
## 数据范围

- `1 ≤ T ≤ 10^4`
- `2 ≤ n ≤ 10^18`

**【测试网站】**

[HDOJ 6030](http://acm.hdu.edu.cn/showproblem.php?pid=6030) 

## 题目分析

 ![image](20180427154248283.png)

 数据范围较大，我们考虑先去找找规律，事实上确实只要推出前几组就可以找到规律
 
 当`i<4`时,`a[i]=i+1`
 
 当`i>=4`时,`a[i]=a[i-2]+a[i-3]+a[i-4]`
 
 这样我们就可以构造出矩阵的转移方程。
  
    | 0 1 1 1 |     | F[n-1] |     |  F[n]  |
    | 1 0 0 0 |  *  | F[n-2] |  =  | F[n-1] |
    | 0 1 0 0 |     | F[n-3] |     | F[n-2] |
    | 0 0 1 0 |     | F[n-4] |     | F[n-3] |


  然后套用矩阵快速幂的模板即可。

## 代码示例

```
#include <bits/stdc++.h>
using namespace std;
#define mst(a,b) memset((a),(b),sizeof(a))
#define f(i,a,b) for(int i=(a);i<(b);++i)
#define ll long long
const int maxn = 4;
const int mod = 1e9+7;
const int INF = 0x3f3f3f3f;
const double eps = 1e-6;
#define rush() int T;scanf("%d",&T);while(T--)
struct Matrix
{
    ll temp[maxn][maxn];
} a;
void init()
{
    f(i,0,maxn)
    f(j,0,maxn)
    {
        a.temp[i][j]=0;
    }
    a.temp[0][1]=a.temp[0][2]=a.temp[0][3]=1;
    a.temp[1][0]=a.temp[2][1]=a.temp[3][2]=1;
}
Matrix mul(Matrix a,Matrix b)
{
    Matrix ans;
    for (int i=0; i<maxn; i++)
        for (int j=0; j<maxn; j++)
        {
            ans.temp[i][j]=0;
            for (int k=0; k<maxn; k++)
            {
                ans.temp[i][j]+=a.temp[i][k]*b.temp[k][j];
                ans.temp[i][j]%=mod;
            }
        }
    return ans;
}
void fun(Matrix ans,ll k)
{
    for(int i=0; i<maxn; i++)
        for(int j=0; j<maxn; j++)
            a.temp[i][j]=(i==j);
    while(k)
    {
        if(k%2)
            a=mul(a,ans);
        ans=mul(ans,ans);
        k/=2;
    }
}
int main()
{
    Matrix t;
    ll n;
    f(i,0,maxn)
    f(j,0,maxn)
    {
        t.temp[i][j]=0;
    }
    t.temp[0][0]=4;
    t.temp[1][0]=3;
    t.temp[2][0]=2;
    t.temp[3][0]=1;
    rush()
    {
        init();
        scanf("%I64d",&n);
        if(n<4)
        {
            printf("%I64d\n",n+1);
            continue;
        }
        fun(a,n-3);
        a=mul(a,t);
        ll ans=a.temp[0][0]%mod;
        printf("%I64d\n",ans);
    }
    return 0;
}
```
   
   
   
