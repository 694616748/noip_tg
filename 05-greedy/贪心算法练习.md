# 贪心算法练习

## 做题链接：[GO](https://vjudge.net/contest/284355)

### Password：aomeng

## 题目一：国王游戏

[洛谷 1080](https://www.luogu.org/problemnew/show/P1080)

### 题意

如题

### 思路

其实我们发现只需要考虑相邻两个数如何交换才是最优的，因为任意排列都可以由交换相邻两个数得到。

假设现在有两个大臣，国王左手为`a0`，右手为`b0`，大臣`1`左手为`a1`,右手为`b1`,大臣`2`左手为`a2`,右手为`b2`.

有两种排列方法：

1. 大臣`1`在前，最后答案为`max（a0/b1,a0*a1/b2）`

2. 大臣`2`在前，最后答案为`max（a0/b2,a0*a2/b1）`

不妨设大臣`1`在前为最后答案，题目要求最大值最小，那么就说明第一个最大值小于第二个最大值

又因为`a0/b1<a0*a2/b1,a0/b2<a0*a1/b2`

那么就说明`a0*a1/b2<a0*a2/b1，即a1*b1<a2*b2`

我们只要这样排序就能满足题意要求，且最大值为最后一个大臣。

注意数据比较大，需要手动模拟高精度。


### 代码

```c++
#include <bits/stdc++.h>
using namespace std;
#define mst(a,b) memset((a),(b),sizeof(a))
#define rush() int T;scanf("%d",&T);while(T--)

typedef long long ll;
const int maxn = 1105;
const ll INF = 1e18;
const ll mod=1e9+7;
const double eps = 1e-9;

int n;
int num[5005];

struct node
{
    int x,y;
}a[maxn];

bool cmp(node a,node b)
{
    return a.x*a.y<b.x*b.y;
}

void mul(int x)
{
    int flag=0;
    for(int i=0;i<5005;i++)
    {
        flag+=num[i]*x;
        num[i]=flag%10000;
        flag/=10000;
    }
}

void div(int x)
{
    int flag=0;
    for(int i=5004;i>=0;i--)
    {
        flag=num[i]+flag*10000;
        num[i]=flag/x;
        flag%=x;
    }
}

int main()
{
    int xx,yy;
    scanf("%d",&n);
    scanf("%d%d",&xx,&yy);
    for(int i=0;i<n;i++)
    {
        scanf("%d%d",&a[i].x,&a[i].y);
    }
    sort(a,a+n,cmp);
    num[0]=xx;
    for(int i=0;i<n-1;i++) mul(a[i].x);
    div(a[n-1].y);
    int now=5004;
    while(now>=0&&num[now]==0) now--;
    if(now==-1) return puts("1"),0;
    printf("%d",num[now--]);
    while(now>=0)
    {
        printf("%04d",num[now--]);
    }
    puts("");
}

```


## 题目一：国王游戏

[洛谷 1080](https://www.luogu.org/problemnew/show/P1080)

### 题意

如题

### 思路

其实我们发现只需要考虑相邻两个数如何交换才是最优的，因为任意排列都可以由交换相邻两个数得到。

假设现在有两个大臣，国王左手为`a0`，右手为`b0`，大臣`1`左手为`a1`,右手为`b1`,大臣`2`左手为`a2`,右手为`b2`.

有两种排列方法：

1. 大臣`1`在前，最后答案为`max（a0/b1,a0*a1/b2）`

2. 大臣`2`在前，最后答案为`max（a0/b2,a0*a2/b1）`

不妨设大臣`1`在前为最后答案，题目要求最大值最小，那么就说明第一个最大值小于第二个最大值

又因为`a0/b1<a0*a2/b1,a0/b2<a0*a1/b2`

那么就说明`a0*a1/b2<a0*a2/b1，即a1*b1<a2*b2`

我们只要这样排序就能满足题意要求，且最大值为最后一个大臣。

注意数据比较大，需要手动模拟高精度。


### 代码

```c++

```


## 题目一：国王游戏

[洛谷 1080](https://www.luogu.org/problemnew/show/P1080)

### 题意

如题

### 思路

其实我们发现只需要考虑相邻两个数如何交换才是最优的，因为任意排列都可以由交换相邻两个数得到。

假设现在有两个大臣，国王左手为`a0`，右手为`b0`，大臣`1`左手为`a1`,右手为`b1`,大臣`2`左手为`a2`,右手为`b2`.

有两种排列方法：

1. 大臣`1`在前，最后答案为`max（a0/b1,a0*a1/b2）`

2. 大臣`2`在前，最后答案为`max（a0/b2,a0*a2/b1）`

不妨设大臣`1`在前为最后答案，题目要求最大值最小，那么就说明第一个最大值小于第二个最大值

又因为`a0/b1<a0*a2/b1,a0/b2<a0*a1/b2`

那么就说明`a0*a1/b2<a0*a2/b1，即a1*b1<a2*b2`

我们只要这样排序就能满足题意要求，且最大值为最后一个大臣。

注意数据比较大，需要手动模拟高精度。


### 代码

```c++

```


## 题目一：国王游戏

[洛谷 1080](https://www.luogu.org/problemnew/show/P1080)

### 题意

如题

### 思路

其实我们发现只需要考虑相邻两个数如何交换才是最优的，因为任意排列都可以由交换相邻两个数得到。

假设现在有两个大臣，国王左手为`a0`，右手为`b0`，大臣`1`左手为`a1`,右手为`b1`,大臣`2`左手为`a2`,右手为`b2`.

有两种排列方法：

1. 大臣`1`在前，最后答案为`max（a0/b1,a0*a1/b2）`

2. 大臣`2`在前，最后答案为`max（a0/b2,a0*a2/b1）`

不妨设大臣`1`在前为最后答案，题目要求最大值最小，那么就说明第一个最大值小于第二个最大值

又因为`a0/b1<a0*a2/b1,a0/b2<a0*a1/b2`

那么就说明`a0*a1/b2<a0*a2/b1，即a1*b1<a2*b2`

我们只要这样排序就能满足题意要求，且最大值为最后一个大臣。

注意数据比较大，需要手动模拟高精度。


### 代码

```c++

```
