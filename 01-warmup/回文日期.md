# P2010 回文日期

## 题目描述

在日常生活中，通过年、月、日这三个要素可以表示出一个唯一确定的日期。

牛牛习惯用8位数字表示一个日期，其中，前 `4`位代表年份，接下来 `2` 位代表月份，最后 `2` 位代表日期。显然：一个日期只有一种表示方法，而两个不同的日期的表 示方法不会相同。

牛牛认为，一个日期是回文的，当且仅当表示这个日期的8位数字是回文的。现 在，牛牛想知道：在他指定的两个日期之间包含这两个日期本身），有多少个真实存 在的日期是回文的。

一个 `8` 位数字是回文的，当且仅当对于所有 `i` `(1≤i≤8)` 从左向右数的第 `i` 个数字和第 `9−i` 个数字（即从右向左数的第 `i` 个数字）是相同的。

例如：

• 对于 `2016` 年 `11` 月 `19` 日，用 `8` 位数字 `20161119` 表示，它不是回文的。

• 对于 `2010` 年 `1` 月 `2` 日，用 `8` 位数字 `20100102` 表示，它是回文的。

• 对于 `2010` 年 `10` 月 `2` 日，用 `8` 位数字 `20101002` 表示，它不是回文的。

每一年中都有 `12` 个月份：

其中 `1,3,5,7,8,10,12` 月每个月有 `31` 天； `4,6,9,11` 月每个月有 `30` 天；而对于 `2` 月，闰年时有 `29` 天，平年时有 `28` 天。

一个年份是闰年当且仅当它满足下列两种情况其中的一种：

1. 这个年份是 `4` 的整数倍，但不是 `100` 的整数倍；

2. 这个年份是 `400` 的整数倍。

例如：

• 以下几个年份都是闰年：`2000,2012,2016`。

• 以下几个年份是平年： `1900,2011,2014`。

## 输入输出格式

### 输入格式：

两行，每行包括一个 `8` 位数字。

第一行表示牛牛指定的起始日期。

第二行表示牛牛指定的终止日期。

保证 `date_i` 和都是真实存在的日期，且年份部分一定为 `4` 位数字，且首位数字不为 `0`。

保证 `date1` —定不晚于 `date2` 。

### 输出格式：

一个整数，表示在 `date1`和 `date2` 之间，有多少个日期是回文的。

## 输入输出样例

### 输入样例#1： 复制

20110101

20111231

### 输出样例#1： 复制
1

### 输入样例#2： 复制

20000101

20101231

### 输出样例#2： 复制
2

## 说明

### 【样例说明】

对于样例1，符合条件的日期是
20111102。

对于样例2，符合条件的日期是
20011002和
20100102。

### 【子任务】

对于60%的数据，满足date1=date2。

## 解题思路

### 思路一

1. 假设在符合回文日期的情况下，输入 `8` 位数对 `10000` 取模得到后四位，后四位再分别对 `100` 取整和取余，得到月和日；
2. 判断当前月和日是否合法（如月不等于0且小于等于12）；
3. 如果合法则对后四位逆序输出得到年份；
4. `8` 位数对 `10000` 取整，得到4四位年份数字，如果该四位数字与根据月日算出来的合法年份一致，则计数器 `+1` ,否则进入下一次循环；
5. 输出计数器的值。

### 思路二

1. 声明两个数组分别存放闰年、平年 `1-12` 月每月的天数；
2. 假设在符合回文日期的前提下，输入对 `10000`取整得到年份，对年份逆序，分别得到月和日；
3. `if` 语句判断该年是闰年还是平年；
4. 在 `if` 语句里判断月和日是否符合条件（如：月不等于 `0` 且小于 `12` ，日是否小于以当前月份为数组下表的值且同样不等于 `0` ），如果满足条件则计数器加 `1` ,不满足则进入下一次循环；
5. 输出计数器的值。

## 代码样例（思路二）
```C++
#include<iostream>
using namespace std;
int main()
{
	
	int count=0;
	int array[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};
	int brray[13]={0,31,29,31,30,31,30,31,31,30,31,30,31};
	int m=0,d=0;
	long long y1,y2;
	cin>>y1>>y2;
	int ya,yb;
	ya=(int)y1/10000;
	yb=(int)y2/10000;
	
	for(int i=ya;i<=yb;i++)
	{
		int j=i;
		int sum=0;
		for(int z=1;z<=4;z++)
		{
			sum=sum*10+j%10;
			j=j/10;
		}
		
		m=sum/100;
		d=sum%100;
		if((j%4==0 && j%100!=0) || j%400==0)
		{
			while(m!=0 && m<=12)
			{
				if(d<=brray[m] && d>0)
					count++;
				break;
			}	
		}
		else
		{
			while(m!=0 && m<=12)
			{
				if(d<=array[m] && d>0)
					count++;
				break;
			}	
		}		
	}
	cout<<count<<endl;

	return 0;
} 
```