# P5016 龙虎斗

##题目描述

轩轩和凯凯正在玩一款叫《龙虎斗》的游戏，游戏的棋盘是一条线段，线段上有 `n` 个兵营（自左至右编号 `1∼n` ），相邻编号的兵营之间相 `1` 厘米，即棋盘为长度为 `n−1` 厘米的线段。`i` 号兵营里有 `ci`位工兵。 下面图 `1` 为 `n=6` 的示例：

![](images/dragon&tiger01.png)

轩轩在左侧，代表 `“龙”` ；凯凯在右侧，代表`“虎”`。 他们以 `m` 号兵营作为分界，靠左的工兵属于龙势力，靠右的工兵属于虎势力，而第 
`m` 号兵营中的工兵很纠结，他们不属于任何一方。

一个兵营的气势为：**该兵营中的工兵数
× 该兵营到 `m` 号兵营的距离**；参与游戏 一方的势力定义为：属于这一方所有兵营的气势之和。下面图 `2` 为 `n=6,m=4` 的示例，其中红色为龙方，黄色为虎方：

![](images/dragon&tiger02.png)

游戏过程中，某一刻天降神兵，共有 `s1` 位工兵突然出现在了 `p1` 号兵营。作为轩轩和凯凯的朋友，你知道如果龙虎双方气势差距太悬殊，轩轩和凯凯就不愿意继续玩下去了。为了让游戏继续，你需要选择一个兵营，并将你手里的 `s2`位工兵全部派往 兵营 `p2`，使得双方气势差距尽可能小。

注意：你手中的工兵落在哪个兵营，就和该兵营中其他工兵有相同的势力归属（如果落在 
`m` 号兵营，则不属于任何势力）。

## 输入输出格式

### 输入格式：

输入文件的第一行包含一个正整数 `n` ，代表兵营的数量。

接下来的一行包含 `n` 个正整数，相邻两数之间以一个空格分隔，第 `i` 个正整数代 表编号为 
`i` 的兵营中起始时的工兵数量 `ci`。

接下来的一行包含四个正整数，相邻两数间以一个空格分隔，分别代表 `m,p1,s1,s2`。

### 输出格式：

输出文件有一行，包含一个正整数，即 `p2`，表示你选择的兵营编号。如果存在多个编号同时满足最优，取最小的编号。

### 输入输出样例

#### 输入样例#1
6  
2 3 2 3 2 3   
4 6 5 2   

#### 输出样例#1
2 

#### 输入样例#2
6   
1 1 1 1 1 16   
5 4 1 1

#### 输出样例#2
1

## 说明

### 输入输出样例 1 说明

见问题描述中的图 `2` 。
双方以 `m=4` 号兵营分界，有 `s1=5` 位工兵突然出现在 `p1=6` 号兵营。  
龙方的气势为：`2×(4−1)+3×(4−2)+2×(4−3)=14`  
虎方的气势为：`2×(5−4)+(3+5)×(6−4)=18`

当你将手中的 `s2 =2` 位工兵派往 `p2=2` 号兵营时，  
龙方的气势变为：`14+2×(4−2)=18`

此时双方气势相等。

### 输入输出样例 2 说明

双方以 `m=5` 号兵营分界，有 `s1=1` 位工兵突然出现在 `p1=4` 号兵营。  
龙方的气势为：
`1×(5−1)+1×(5−2)+1×(5−3)+(1+1)×(5−4)=11`
虎方的气势为：`16×(6−5)=16`

当你将手中的 `s2=1` 位工兵派往 `p2=1` 号兵营时，  
龙方的气势变为：`11+1×(5−1)=15`

此时可以使双方气势的差距最小。

【数据规模与约定】
`1<m<n,1≤p1≤n`。
对于20% 的数据,`n=3,m=2,ci=1,s1,s2≤100`。
另有 `20%` 的数据，`n≤10,p 1=m,ci =1,s1,s2≤100`。
对于 `60%` 的数据，`n≤100,c i=1,s1,s2≤100` 。
对于 `80%` 的数据 `n≤100^5,ci,s1,s2≤100` 。
对于 `100%` 的数据，`n≤10^5,ci,s1,s2≤10^9` 。

## 解题思路

1. 声明一个数组存放 `1-n` 每个兵营的士兵数量；
2. 根据 `m` 号兵营利用 `if` 语句分别算出龙势力和虎势力，比较其势力大小，决定我手中的工兵派往势力相对弱的一方；
3. 声明一个变量用来存放双方势力差值；
4. 利用循环将我手中工兵依次放入势力弱的一方，然后与势力强的一方比较，记录势力差值，如果势力差值比上一次的势力差值小，则更新最小差值，记录此时的兵营编号；
5. 循环结束，输出势力差值最小时对应的兵营编号；


## 代码展示

```C++
#include<bits/stdc++.h>
using namespace std;

long long abs(long long x, long long y)
{
	if(x>=y)	return x-y;
	else	return y-x;
}

int main()
{
	long long m,p1,p2;
	int n;
	long long s1,s2;
	long long dragon=0,tiger=0;
	long long soldier[100005];
	long long min=1e19;
	
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>soldier[i];
	}
	cin>>m>>p1>>s1>>s2;
	
	soldier[p1]=soldier[p1]+s1;
	
	for(int i=1;i<m;i++)
	{
		dragon+=soldier[i]*(m-i);
	}
	 
	for(int j=m+1;j<=n;j++)
	{
		tiger+=soldier[j]*(j-m);
	}
	
	for(int i = 1; i <= n; i ++ ) {
        if(i < m) dragon += (m - i) * s2;
        else if(i > m) tiger += (i - m) * s2;//算出新的双方势力
        long long tmp = abs(dragon, tiger);//相减后算绝对值
        if(min > tmp) {
            min = tmp;
            p2 = i;
        }
        if(i < m) dragon -= (m - i) * s2;
        else if(i > m) tiger -= (i - m) * s2;//退栈
    }
	
	cout<<p2<<endl;
	
	return 0;
}
```